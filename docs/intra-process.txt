**********************
* evm_message_pass() *
**********************
        VS
**********************
* evm_message_call() *
**********************

This test shows the difference in CPU usage distrubution when
running a tight loop example whithin a single process/thread 
using different methods to send/receive a message in a loop.

The "evm_message_pass()" method involves queueing a message and
writing into a "eventfd" FD, which unblocks the "epoll()" method
to eventually receive the message.

The "evm_message_call()" method only enqueues a message without
notifying the "epoll()" mechanism. This method avoids the "epoll()" 
mechanism (a few system calls), when used to send messages 
within the same scheduling context (same thread).

If "evm_message_call()" is used to send a message to a message
queue of another thread, the message is going to stay in a
queue until another thread's "epoll()" method is unblocked.

Local messages (evm_message_pass() - with FD triggering):
=========================================================
samo@lapuh:~/EVM/evm/build/demos$ time ./hello_evm
[57760.372975|28283|DEMO_EVM] IDLE timer set: 0 s
[57760.373044|28283|DEMO_EVM] QUIT timer set: 60 s
[57760.373069|28283|DEMO_EVM] IDLE timer expired!
[57760.373093|28283|DEMO_EVM] HELLO msg sent: "HELLO: 1"
[57820.373058|28283|DEMO_EVM] QUIT timer expired (30403105 messages sent)!

real	1m0.002s
user	0m19.444s
sys	0m40.552s

Local messages (evm_message_call() - no FD triggering):
=======================================================
samo@lapuh:~/EVM/evm/build/demos$ time ./hello_evm
[60378.760735|28569|DEMO_EVM] IDLE timer set: 0 s
[60378.760804|28569|DEMO_EVM] QUIT timer set: 60 s
[60378.760829|28569|DEMO_EVM] IDLE timer expired!
[60378.760851|28569|DEMO_EVM] HELLO msg sent: "HELLO: 1"
[60438.760825|28569|DEMO_EVM] QUIT timer expired (36337635 messages sent)!

real	1m0.003s
user	0m20.148s
sys	0m39.844s

